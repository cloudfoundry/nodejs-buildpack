'use strict'

var http = require('http'),
  https = require('https'),
  HttpsProxyAgent = require('https-proxy-agent'),
  fs = require('fs-extra'),
  tar = require('tar'),
  url = require('url'),
  path = require('path'),
  os = require('os');

var target = process.argv[2],
  srcPackage = process.argv[3],
  targetPlatform = process.platform,
  targetArch = process.arch;

console.log("installing package" + target);
console.log(process.version);

var validExit = false; // If the process exits without going through exit(), then we did not complete.
var pkgPath = __dirname; // we utilize __dirname (point to location of install.js script) to find path to copy binary module to
var BASE_URL = process.env.APPD_CDN_BASE_URL || process.env.npm_config_appd_cdn_base_url || "https://cdn.appdynamics.com/packages/nodejs/"; // https://cdn.appdynamics.com/packages/nodejs/4.5.2.0/appdynamics-libagent-node-osx-x64-v8.tgz

// for staging the url is https://packages-staging.corp.appdynamics.com/raw/nodejs/4.5.2.0/appdynamics-libagent-node-osx-x64-v8.tgz
if (process.env.APPD_STAGE === 'true')
  BASE_URL = "https://packages-staging.corp.appdynamics.com/raw/nodejs/"

console.log('Testing: BaseUrl set is:' + BASE_URL);
console.log('Get agent version result is:' + getAgentVersion());

function getAgentVersion() {
  var packageJsonPath = path.join(pkgPath, 'package.json'),
    packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8')),
    agentVersion = packageJson.version;
  if (process.env.APPD_STAGE === 'true') {
    agentVersion = process.argv[4];
  }
  console.log('Agent version ' + agentVersion);
  if (!agentVersion) {
    return null
  }
  return agentVersion + '.0'
}

function getNodeVersion() {
  var nodeVersion = process.version,
    versionArray = nodeVersion.split(".");
  if (versionArray.length < 2) {
    return null;
  } else if (versionArray[0] == "v0") {
    return versionArray[0] + '.' + versionArray[1];
  } else {
    return versionArray[0];
  }
}

function getPlatformString() {
  if (targetPlatform === 'linux') {
    if (fs.existsSync("/etc/alpine-release")) {
      return 'linux-alpine';
    } else {
      return 'linux';
    }
  } else if (targetPlatform === 'darwin') {
    return 'osx';
  } else if (targetPlatform === 'win32') {
    return 'win32';
  } else {
    return null;
  }
}

function getPlatformArchString() {
  if (targetArch === 'x64') {
    return 'x64';
  } else if (
    targetPlatform === 'win32' && (targetArch === 'x86' || targetArch === 'ia32')) {
    return 'ia32';
  } else if (
    targetPlatform === 'linux' && (targetArch === 'x86' || targetArch === 'ia32')) {
    return 'x86';
  } else {
    return null;
  }
}

function exit(code) {
  validExit = true;
  process.exit(code || 0);
}

function getDownloadSpec(moduleName) {
  var platformString = getPlatformString(),
    platformArchString = getPlatformArchString(),
    agentVersion = getAgentVersion(),
    nodeVersion = getNodeVersion();
  if (!platformArchString || !platformString || !agentVersion || !moduleName || !nodeVersion) {
    return null;
  }
  console.log("baseUrl is:" + BASE_URL);
  var downloadUrl = BASE_URL + agentVersion + '/' + moduleName + '-' + platformString + '-' + platformArchString + '-' + nodeVersion + '.tgz';
  console.log("DownloadURL is:" + downloadUrl);
  return { url: downloadUrl };
}

function findTempDirectory() {
  var now = Date.now(),
    candidateTmpDirs = [
      process.env.npm_config_tmp,
      os.tmpdir(),
      path.join(process.cwd(), 'tmp')
    ];

  for (var i = 0; i < candidateTmpDirs.length; i++) {
    var candidatePath = candidateTmpDirs[i];
    if (!candidatePath) continue;

    try {
      candidatePath = path.join(path.resolve(candidatePath), 'appdynamics-' + getAgentVersion());
      if (fs.existsSync(candidatePath)) 
        return candidatePath;
      try {
        fs.mkdirSync(candidatePath, { recursive: true });
      } catch (e) {
        // ignore; existsSync my lie :-(
        console.log(e);
      }
      fs.chmodSync(candidatePath, '0777');
      var testFile = path.join(candidatePath, now + '.tmp');
      fs.writeFileSync(testFile, 'test');
      fs.unlinkSync(testFile);
      return candidatePath;
    } catch (e) {
      console.log(candidatePath + ' is not writable: ' + e.message);
    }
  }

  console.error('Can not find a writable tmp directory, please report issue ')
  exit(1)
}

function getRequestOptions(downloadUrl) {
  var strictSSL = !!process.env.npm_config_strict_ssl;
  if (process.version == 'v0.10.34') {
    console.log('Node v0.10.34 detected, turning off strict ssl due to https://github.com/joyent/node/issues/8894');
    strictSSL = false;
  }

  let uri = new URL(downloadUrl);

  var options = {
    uri: downloadUrl,
    followRedirect: true,
    headers: {},
    gzip: true,
    encoding: null, // Get response as a buffer
    strictSSL: strictSSL,
    hostname: uri.hostname,
    path: uri.pathname,
  };

  var proxyUrl = process.env.npm_config_https_proxy ||
    process.env.npm_config_http_proxy ||
    process.env.npm_config_proxy;
  if (proxyUrl) {
    // Print using proxy
    var proxy = url.parse(proxyUrl);
    if (proxy.auth) {
      // Mask password
      proxy.auth = proxy.auth.replace(/:.*$/, ':******');
    }
    console.log('Using proxy ' + url.format(proxy));

    // Enable proxy
    options.proxy = proxyUrl;
    var agent = new HttpsProxyAgent(proxy);
    options.agent = agent;
  }

  // Use the user-agent string from the npm config
  var user_agent = process.env.npm_config_user_agent || "npm/2.14.2 node/v4.0.0 darwin x64";
  console.log('user agent: ' + user_agent);
  options.headers['User-Agent'] = user_agent;

  // Use certificate authority settings from npm
  var ca = process.env.npm_config_ca;
  if (!ca && process.env.npm_config_cafile) {
    try {
      ca = fs.readFileSync(process.env.npm_config_cafile, { encoding: 'utf8' })
        .split(/\n(?=-----BEGIN CERTIFICATE-----)/g);

      // Comments at the beginning of the file result in the first
      // item not containing a certificate - in this case the
      // download will fail
      if (ca.length > 0 && !/-----BEGIN CERTIFICATE-----/.test(ca[0])) {
        ca.shift();
      }

    } catch (e) {
      console.error('Could not read cafile ' + process.env.npm_config_cafile + ' ' + e);
    }
  }

  if (ca) {
    console.log('Using npmconf ca');
    options.agentOptions = {
      ca: ca
    };
    options.ca = ca;
  }

  return options;
}

function downloadAppdynamics(moduleName, cb) {
  var downloadSpec = getDownloadSpec(moduleName);
  if (!downloadSpec) {
    console.error(
      'Unexpected platform or architecture: ' + targetPlatform + '/' + targetArch + '\n' +
      'It seems there is no binary available for your platform/architecture\n');
    exit(1);
  }

  var downloadUrl = downloadSpec.url,
    downloadedFile;

  console.log(downloadUrl);
  var tmpPath = findTempDirectory(),
    fileName = downloadUrl.split('/').pop();
  downloadedFile = path.join(tmpPath, fileName);
  if (fs.existsSync(downloadedFile)) {
    console.log('Download already available at' + downloadedFile);
    return cb(null, downloadedFile);
  } else {
    console.log('Downloading' + downloadUrl);
    console.log('Saving to' + downloadedFile);
    requestBinary(getRequestOptions(downloadUrl), downloadedFile, cb);
  }
}

function handleRequestError(error) {
  if (error && error.stack && error.stack.indexOf('SELF_SIGNED_CERT_IN_CHAIN') != -1) {
    console.error('Error making request, SELF_SIGNED_CERT_IN_CHAIN.');
    exit(1);
  } else if (error) {
    console.error('Error making request.\n' + error.stack + '\n\n');
    exit(1);
  } else {
    console.error('Something unexpected happened\n', error);
    exit(1);
  }
}

function requestBinary(requestOptions, filePath, cb) {
  var writePath = filePath + '-download-' + Date.now();
  console.log('Receiving... ' + requestOptions.uri);

  const url = new URL(requestOptions.uri);
  const agent = url.protocol === 'https:' ? https : http;

  agent.request(requestOptions, (res) => {
      let file = fs.createWriteStream(writePath);

      res.on('data', (chunk) => {
        file.write(chunk);
      });
      res.on('end', () => {
        try {
          if (res.statusCode == 200) {
            console.log(
              'Received ' + Math.floor(file.bytesWritten / 1024) + 'K total.'
            );
            file.end(() => {
              try {
                fs.renameSync(writePath, filePath);
                cb(null, filePath)
              } catch(err) {
                handleRequestError(err);
              }
            });
          } else {
            console.error(
              'Error requesting archive.\n' +
                'Status: ' +
                res.statusCode +
                '\n' +
                'Request options: ' +
                JSON.stringify(requestOptions, null, 2) +
                '\n' +
                'Response headers: ' +
                JSON.stringify(res.headers, null, 2) +
                '\n' +
                'Make sure your network and proxy settings are correct.\n\n'
            );
            exit(1);
          }
        } catch (err) {
          handleRequestError(err);
        }
      });
    })
    .end();
}

function deleteNodeModules(cb) {
  console.log('Going to delete the node_modules folder');
  fs.remove(path.join(pkgPath, 'node_modules/'), function (err) {
    cb(err);
  });
}

process.on('exit', function () {
  if (!validExit) {
    console.log('Install exited unexpectedly');
    exit(1)
  }
});

function extractWithTar(filePath, cb) {
  console.log('Extracting file: ' + filePath);
  tar.x({
    file: filePath,
    strip: 1
  }).then(function resolve(data) {
    cb(null);
  }, function reject(err) {
    cb(err);
  });
}

downloadAppdynamics(target, function (err, downloadPath) {
  if (err) {
    exit(1);
  }
  extractWithTar(downloadPath, function (err, extractPath) {
    if (err) {
      exit(1);
    }
    deleteNodeModules(function (err) {
      if (!err) exit(0);
    });
  });
});