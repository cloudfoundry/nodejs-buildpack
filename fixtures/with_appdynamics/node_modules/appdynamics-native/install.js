'use strict'

var request = require('request'),
  fs = require('fs-extra'),
  unpack = require('tar-pack').unpack,
  url = require('url'),
  path = require('path'),
  os = require('os');

var target = process.argv[2],
  srcPackage = process.argv[3],
  targetPlatform = process.platform,
  targetArch = process.arch;

console.log("installing package" + target);
console.log(process.version);

var validExit = false; // If the process exits without going through exit(), then we did not complete.
var pkgPath = __dirname; // we utilize __dirname (point to location of install.js script) to find path to copy binary module to
var BASE_URL = process.env.APPD_CDN_BASE_URL || process.env.npm_config_appd_cdn_base_url || "https://cdn.appdynamics.com/packages/nodejs/"; // https://cdn.appdynamics.com/packages/nodejs/4.5.2.0/appdynamics-libagent-node-osx-x64-v8.tgz

// for staging the url is https://packages-staging.corp.appdynamics.com/raw/nodejs/4.5.2.0/appdynamics-libagent-node-osx-x64-v8.tgz
if (process.env.APPD_STAGE === 'true')
  BASE_URL = "https://packages-staging.corp.appdynamics.com/raw/nodejs/"

console.log(process.env)

console.log('Testing: BaseUrl set is:' + BASE_URL);
console.log('Get agent version result is:' + getAgentVersion());

function getAgentVersion() {
  var packageJsonPath = path.join(pkgPath, 'package.json'),
    packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8')),
    agentVersion = packageJson.version;
  if (process.env.APPD_STAGE === 'true') {
    agentVersion = process.argv[4];
  }
  console.log('Agent version ' + agentVersion);
  if (!agentVersion) {
    return null
  }
  return agentVersion + '.0'
}

function getNodeVersion() {
  var nodeVersion = process.version,
    versionArray = nodeVersion.split(".");
  if (versionArray.length < 2) {
    return null;
  } else if (versionArray[0] == "v0") {
    return versionArray[0] + '.' + versionArray[1];
  } else {
    return versionArray[0];
  }
}

function getPlatformString() {
  if (targetPlatform === 'linux') {
    if (fs.existsSync("/etc/alpine-release")) {
      return 'linux-alpine';
    } else {
      return 'linux';
    }
  } else if (targetPlatform === 'darwin') {
    return 'osx';
  } else if (targetPlatform === 'win32') {
    return 'win32';
  } else {
    return null;
  }
}

function getPlatformArchString() {
  if (targetArch === 'x64') {
    return 'x64';
  } else if (targetPlatform === 'win32' && (targetArch === 'x86' || targetArch === 'ia32')) {
    return 'ia32';
  } else if (targetPlatform === 'linux' && (targetArch === 'x86' || targetArch === 'ia32')) {
    return 'x86';
  } else {
    return null;
  }
}

function exit(code) {
  validExit = true;
  process.exit(code || 0);
}

function getDownloadSpec(moduleName) {
  var platformString = getPlatformString(),
    platformArchString = getPlatformArchString(),
    agentVersion = getAgentVersion(),
    nodeVersion = getNodeVersion();
  if (!platformArchString || !platformString || !agentVersion || !moduleName || !nodeVersion) {
    return null;
  }
  console.log("baseUrl is:" + BASE_URL);
  var downloadUrl = BASE_URL + agentVersion + '/' + moduleName + '-' + platformString + '-' + platformArchString + '-' + nodeVersion + '.tgz';
  console.log("DownloadURL is:" + downloadUrl);
  return { url: downloadUrl };
}

function findTempDirectory() {
  var now = Date.now(),
    candidateTmpDirs = [
      process.env.npm_config_tmp,
      os.tmpdir(),
      path.join(process.cwd(), 'tmp')
    ];

  for (var i = 0; i < candidateTmpDirs.length; i++) {
    var candidatePath = candidateTmpDirs[i];
    if (!candidatePath) continue;

    try {
      candidatePath = path.join(path.resolve(candidatePath), 'appdynamics-' + getAgentVersion());
      if (fs.existsSync(candidatePath))
        return candidatePath;
      fs.mkdirSync(candidatePath);
      fs.chmodSync(candidatePath, '0777');
      var testFile = path.join(candidatePath, now + '.tmp');
      fs.writeFileSync(testFile, 'test');
      fs.unlinkSync(testFile);
      return candidatePath;
    } catch (e) {
      console.log(candidatePath + 'is not writable: ' + e.message);
    }
  }

  console.error('Can not find a writable tmp directory, please report issue ')
  exit(1)
}

function getRequestOptions(downloadUrl) {
  var strictSSL = !!process.env.npm_config_strict_ssl;
  if (process.version == 'v0.10.34') {
    console.log('Node v0.10.34 detected, turning off strict ssl due to https://github.com/joyent/node/issues/8894');
    strictSSL = false;
  }

  var options = {
    uri: downloadUrl,
    followRedirect: true,
    headers: {},
    gzip: true,
    encoding: null, // Get response as a buffer
    strictSSL: strictSSL
  };

  var proxyUrl = process.env.npm_config_https_proxy ||
    process.env.npm_config_http_proxy ||
    process.env.npm_config_proxy;
  if (proxyUrl) {

    // Print using proxy
    var proxy = url.parse(proxyUrl);
    if (proxy.auth) {
      // Mask password
      proxy.auth = proxy.auth.replace(/:.*$/, ':******');
    }
    console.log('Using proxy ' + url.format(proxy));

    // Enable proxy
    options.proxy = proxyUrl;
  }

  // Use the user-agent string from the npm config
  var user_agent = process.env.npm_config_user_agent || "npm/2.14.2 node/v4.0.0 darwin x64";
  console.log('user agent: ' + user_agent);
  options.headers['User-Agent'] = user_agent;

  // Use certificate authority settings from npm
  var ca = process.env.npm_config_ca;
  if (!ca && process.env.npm_config_cafile) {
    try {
      ca = fs.readFileSync(process.env.npm_config_cafile, { encoding: 'utf8' })
        .split(/\n(?=-----BEGIN CERTIFICATE-----)/g);

      // Comments at the beginning of the file result in the first
      // item not containing a certificate - in this case the
      // download will fail
      if (ca.length > 0 && !/-----BEGIN CERTIFICATE-----/.test(ca[0])) {
        ca.shift();
      }

    } catch (e) {
      console.error('Could not read cafile ' + process.env.npm_config_cafile + ' ' + e);
    }
  }

  if (ca) {
    console.log('Using npmconf ca');
    options.agentOptions = {
      ca: ca
    };
    options.ca = ca;
  }

  return options;
}

function downloadAppdynamics(moduleName, cb) {
  var downloadSpec = getDownloadSpec(moduleName);
  if (!downloadSpec) {
    console.error(
      'Unexpected platform or architecture: ' + targetPlatform + '/' + targetPlatformArch + '\n' +
      'It seems there is no binary available for your platform/architecture\n');
    exit(1);
  }

  var downloadUrl = downloadSpec.url,
    downloadedFile;

  console.log(downloadUrl);
  var tmpPath = findTempDirectory(),
    fileName = downloadUrl.split('/').pop();
  downloadedFile = path.join(tmpPath, fileName);
  if (fs.existsSync(downloadedFile)) {
    console.log('Download already available at' + downloadedFile);
    return cb(null, downloadedFile);
  } else {
    console.log('Downloading' + downloadUrl);
    console.log('Saving to' + downloadedFile);
    requestBinary(getRequestOptions(downloadUrl), downloadedFile, cb);
  }
}

function handleRequestError(error) {
  if (error && error.stack && error.stack.indexOf('SELF_SIGNED_CERT_IN_CHAIN') != -1) {
    console.error('Error making request, SELF_SIGNED_CERT_IN_CHAIN.');
    exit(1);
  } else if (error) {
    console.error('Error making request.\n' + error.stack + '\n\n');
    exit(1);
  } else {
    console.error('Something unexpected happened');
    exit(1);
  }
}

function requestBinary(requestOptions, filePath, cb) {
  var writePath = filePath + '-download-' + Date.now();

  console.log('Receiving... ' + requestOptions.uri);
  request(requestOptions, function (error, response, body) {
    console.log('');
    if (!error && response.statusCode === 200) {
      fs.writeFileSync(writePath, body);
      console.log('Received ' + Math.floor(body.length / 1024) + 'K total.');
      fs.renameSync(writePath, filePath);
      cb(null, filePath);
    } else if (response) {
      console.error('Error requesting archive.\n' +
        'Status: ' + response.statusCode + '\n' +
        'Request options: ' + JSON.stringify(requestOptions, null, 2) + '\n' +
        'Response headers: ' + JSON.stringify(response.headers, null, 2) + '\n' +
        'Make sure your network and proxy settings are correct.\n\n');
      exit(1);
    } else {
      handleRequestError(error);
    }
  });
}

function copyToPackages(extractPath, pkgPath, target, cb) {
  console.log("copying binary into packages");
  var srcPath = path.join(extractPath, target);
  if (fs.existsSync(srcPath)) {
    fs.copy(srcPath, path.join(pkgPath), function (err) {
      if (err)
        cb(err);
      else
        cb();
    });
  } else {
    console.log('Could not find extracted file', srcPath);
    exit(1);
  }
}

function extractDownload(filePath, cb) {
  var extractedPath = filePath + '-extract-' + Date.now();
  var read = fs.createReadStream;
  console.log('Extracting ' + filePath + ' -> ' + extractedPath);
  fs.remove(extractedPath, function () {
    read(filePath).pipe(unpack(path.join(extractedPath, srcPackage), function (err) {
      if (err) {
        console.log("Error in untarring" + err);
        cb(err);
      } else {
        cb(null, extractedPath);
      }
    }));
  });
}

function deleteNodeModules(cb) {
  console.log('Going to delete the node_modules folder');
  fs.remove(path.join(pkgPath, 'node_modules/'), function (err) {
    cb(err);
  });
}

process.on('exit', function () {
  if (!validExit) {
    console.log('Install exited unexpectedly');
    exit(1)
  }
});

downloadAppdynamics(target, function (err, downloadPath) {
  if (err)
    exit(1);
  extractDownload(downloadPath, function (err, extractPath) {
    if (err)
      exit(1);
    copyToPackages(extractPath, pkgPath, srcPackage, function (err) {
      if (err)
        exit(1);
      deleteNodeModules(function (err) {
        if (!err)
          exit(0);
      });
    });
  })
});
